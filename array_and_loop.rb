# frozen_string_literal: false

# 4 配列や繰り返し処理を理解する
# 4.2 配列
# 配列とは複数のデータをまとめて格納できるオブジェクト
# 配列は[]と,を使って作成する（配列リテラル）
# 空の配列を作る
p []
# 3つの要素が格納された配列を作る [要素1,要素2,要素3]
p [1, 2, 3]
# 配列は Array オブジェクト
p [].class #=> Array

# 変数aに配列を代入
a = [1, 2, 3]
p a

# 異なるデータ型を格納可能 ex)数値と文字列
a = [1, 'apple', 2, 'orange', 3, 'melon']
p a

# 配列の中に配列を格納可能
a = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]
p a

# 配列の各要素を取得する場合は、[]と添え字（数値）を使用
a = [1, 2, 3]
p a
# 1つめの要素を取得
p a[0] #=>1
# 2つめの要素を取得
p a[1] #=>2
# 3つめの要素を取得
p a[2] #=>3
# 存在しない要素を取得
p a[100] #=>nil
# を配列の長さ（要素の個数）を取得
# sizeメソッド（エイリアスメソッド: length）
p a.size #=>3
p a.length #=>3

# 4.2.1 要素の変更、追加、削除
# 指定した要素を変更
# 配列[添字] = 新しい値
a = [1, 2, 3]
a[1] = 20
p a #=> [1, 20, 3]

# 配列の最後に要素を追加
a = []
a << 1
a << 2
a << 3
p a #=> [1, 2, 3]

# 配列内の特定の位置にある要素を削除したい場合はdelete_atメソッドを使う
a = [1, 2, 3]
# 2番目の要素を削除（削除した値が戻り値）
p a.delete_at(1) #=>2
p a #=> [1,3]

# 4.2.2 配列を使った多重代入
a, b = [1, 2]
p a #=> 1
p b #=> 2

# 4.3 ブロック
# ブロックはメソッドの引数として渡すことができる処理のかたまり
# ブロック内で記述した処理は必要に応じてメソッドから呼び出される

# 4.3.2 Rubyの繰り返し処理
# do ~ end がブロックの範囲
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum += n
end
p sum #=>10

# 4.3.3 配列の要素を削除する条件を自由に指定する

# 配列から値が2の要素を削除
a = [1, 2, 3, 1, 2, 3]
a.delete(2) #=>[1,3,1,3]
p a

# 配列から値が奇数の要素を削除
# ブロックの戻り値が true なら削除
a = [1, 2, 3, 1, 2, 3]
a.delete_if do |n|
  n.odd?
end
p a #=>[2,2]

# 4.3.5 do...endと{}
numbers = [1, 2, 3, 4]
sum = 0
# do...endの代わりに{}を使用
numbers.each { |n| sum += n }
p sum #=>10

# 4.4 ブロックを使う配列のメソッド
# 4.4.1 map/collect
# エイリアスメソッドはcollect
# mapメソッドは各要素に対してブロックを評価した結果を新しい配列にして返す

# 例) に配列の各要素を10倍した新しい配列を作る
# each メソッドの場合
numbers = [1, 2, 3, 4, 5]
new_numbers = []
numbers.each { |n| new_numbers << n * 10 }
p new_numbers #=>[10,20,30,40,50]

# map メソッドの場合
numbers = [1, 2, 3, 4, 5]
# ブロックの戻り値が新しい配列の各要素になる
new_numbers = numbers.map { |n| n * 10 }
p new_numbers #=>[10,20,30,40,50]

# 4.4.2 select/find_all/reject
# selectメソッド（エイリアスメソッドはfind_all）は各要素に対してブロックを評価し、その戻り値が真の要素を集めた配列を返すメソッド

# 例) 偶数の数値だけを集めた配列を新たに作る
numbers = [1, 2, 3, 4, 5, 6]
# ブロックの戻り値が真になった要素だけが集められる
even_numbers = numbers.select { |n| n.even? }
p even_numbers #=>[2,4,6]

# rejectメソッドはselectメソッドの反対
# ブロックの戻り値が真になった要素を除外した配列を返す = ブロックの戻り値が偽である要素を集めるメソッド
numbers = [1, 2, 3, 4, 5, 6]
# 3の倍数を除外する（3の倍数以外を集める
non_multiples_of_three = numbers.reject { |n| (n % 3).zero? }
p non_multiples_of_three #=>[1,2,4,5]

# 4.4.3 find/detect
# findメソッド（エイリアスメソッドはdetect）はブロックの戻り値が真になった最初の要素を返す
numbers = [1, 2, 3, 4, 5, 6]
# ブロックの戻り値が最初に真になった要素を返す
even_number = numbers.find { |n| n.even? }
p even_number #=>2

# 4.4.5 &とシンボルを使ってもっと簡潔に書く

p %w[ruby java perl].map { |s| s.upcase } #=>["RUBY","JAVA","PERL"]
p %w[ruby java perl].map(&:upcase) #=>["RUBY","JAVA","PERL"]

p [1, 2, 3, 4, 5, 6].select { |n| n.odd? } #=>[1,3,5]
p [1, 2, 3, 4, 5, 6].select(&:odd?) #=>[1,3,5]

# mapメソッドやselectメソッドにブロックを渡す代わりに、[&:メソッド名]という引数を渡す
# 以下条件
# ①ブロック引数が1個だけである。
# ②ブロックの中で呼び出すメソッドには引数がない。
# ③ブロックの中では、ブロック引数に対してメソッドを1回呼び出す以外の処理がない。

# 4.5 範囲 (range)
# 最初の値..最後の値（最後の値を含む）
# 最初の値...最後の値（最後の値を含まない）

# 範囲オブジェクトは Range クラスのオブジェクト
p (1..5).class #=>Range
p ('a'...'e').class #=>Range

# ..を使うと5が範囲に含まれる（1以上5以下）
range = 1..5
p range.include?(0) #=>false
p range.include?(1) #=>true
p range.include?(4.9) #=>true
p range.include?(5) #=>true
p range.include?(6) #=>false

# ...を使うと5が範囲に含まれない（1以上5未満）
range = 1...5
p range.include?(0) #=>false
p range.include?(1) #=>true
p range.include?(4.9) #=>true
p range.include?(5) #=>false
p range.include?(6) #=>false

# 4.5.1 配列や文字列の一部を抜き出す
# 配列に対して添え字の代わりに範囲オブジェクトを渡すと、指定した範囲の要素を取得可能
a = [1, 2, 3, 4, 5]
# 2番目から4番目までの要素を取得する
p a[1..3] #=>[2,3,4]
p a[2..6] #=>[3,4,5]

# 文字列に対しても同じような操作が可能
a = 'abcdef'
# 2文字目から4文字目までを抜き出す
p a[1..3] #=>"bcd"

# 4.5.2 n以上m以下、n以上m未満の判定をする
# 不等号を使う場合
def liquid?(temperature)
  # 0度以上100度未満であれば液体と判定
  0 <= temperature && temperature < 100
end
p liquid?(1) #=>false
p liquid?(0) #=>true
p liquid?(99) #=>truel
p liquid?(100) #=>false

# 範囲オブジェクトを使う場合
def ekitai?(temperature)
  (0...100).include?(temperature)
end
p ekitai?(1) #=>false
p ekitai?(0) #=>true
p ekitai?(99) #=>true
p ekitai?(100) #=>false

# 4.5.3 case文で使う
# 年齢に応じて料金を判定するメソッドの実装例で
def charge(age)
  case age
  # 0歳から5歳までの場合
  when 0..5
    0
  # 6歳から12歳までの場合
  when 6..12
    300
  # 13歳から18歳までの場合
  when 13..18
    600
  # それ以外の場合
  else
    1000
  end
end
p charge(3) #=>0
p charge(12) #=>300
p charge(16) #=>600
p charge(25) #=>1000

# 4.5.4 値が連続する配列を作成する
# 範囲オブジェクトに対してto_aメソッドを呼び出すと、値が連続する配列を作成できる
p (1..5).to_a #=>[1,2,3,4,5]
p (1...5).to_a #=>[1,2,3,4]
p ('a'..'e').to_a #=>["a","b","c","d","e"]
p ('a'...'e').to_a #=>["a","b","c","d"]
p ('bad'..'bag').to_a #=>["bad","bae","baf","bag"]
p ('bad'...'bag').to_a #=>["bad","bae","baf"]

# []の中に*と範囲オブジェクトを書いても同じように配列を作ることができる
# *を使って複数の値を配列に展開することをsplat展開という
p [*1..5] #=>[1,2,3,4,5]
p [*1...5] #=>[1,2,3,4]

# 4.5.5 繰り返し処理を行う
# 範囲オブジェクトを配列に変換してから繰り返し処理を行う
numbers = (1..4).to_a
sum = 0
numbers.each { |n| sum += n }
p sum #=>10

# 配列に変換しなくても、範囲オブジェクトに対して直接eachメソッドを呼び出すことも可能
sum = 0
# 範囲オブジェクトに対して直接eachメソッドを呼び出す
(1..4).each { |n| sum += n }
p sum #=>10

# stepメソッドを呼び出すと値を増やす間隔を指定
numbers = []
# 1から10まで2つ飛ばしで繰り返し処理を行う
(1..10).step(2) { |n| numbers << n }
p numbers #=>[1,3,5,7,9]

# 4.6 RGB変換プログラムを作成する
# 仕様
# ・10進数を16進数に変換するto_hexメソッドと、16進数を10進数に変換するto_intsメソッドの2つを定義する。
# ・to_hexメソッドは3つの整数を受け取り、それぞれを16進数に変換した文字列を返す。文字列の先頭には“#”を付ける。
# ・to_intsメソッドはRGBカラーを表す16進数文字列を受け取り、R、G、Bのそれぞれを10進数の整数に変換した値を配列として返す。

# 4.6.1 ~ 4.6.5 は別ファイルにて作成

# 4.7.1 さまざまな要素の取得方法
# 添え字を2つ使うと、添え字の位置と取得する長さを指定
# 配列[位置,取得する長さ]

# 2つめの要素から3つ分の要素を取り出すコード
a = [1, 2, 3, 4, 5]
p a[1, 3] #=>[2,3,4]

# values_atメソッドを使うと、取得したい要素の添え字を複数指定可能
a = [1, 2, 3, 4, 5]
p a.values_at(0, 2, 4) #=>[1,3,5]

# 「配列の長さ－1」を指定すれば、最後の要素を取得可能
a = [1, 2, 3]
# 最後の要素を取得する
p a.size #=>3
p a[a.size - 1] #=>3

a = [1, 2, 3]
# 最後の要素を取得する
p a[-1] #=>3
# 最後から2番目の要素を取得する
p a[-2] #=>2
# 最後から2番目の要素から2つの要素を取得する
p a[-2, 2] #=>[2,3]

# 配列にはlastというメソッドがああり、これを呼ぶと配列の最後の要素を取得可能
# 引数に0以上の数値を渡すと、最後のn個の要素を取得可能
a = [1, 2, 3]
p a.last #=>3
p a.last(2) #=>[2,3]

# lastの反対のfirstもあり、これは先頭の要素を取得するメソッド
a = [1, 2, 3]
p a.first #=>1
p a.first(2) #=>[1,2]

# 4.7.2 さまざまな要素の変更方法
# 値を変更する場合も負の添え字が使用可能
# ただし、正の値を使う場合と異なり、元の大きさを超えるような添え字を指定するとエラーになる

a = [1, 2, 3]
a[-3] = 10 #=>[10,2,3]
# 指定可能な負の値よりも小さくなるとエラーが発生する
# a[-4] = 0 #=>IndexError:index4toosmallforarray;minimum:3

# 開始位置と長さを指定して要素を置き換えることも可能
a = [1, 2, 3, 4, 5]
# 2つめから3要素分を100で置き換える
a[1, 3] = 100
p a #=>[1,100,5]

# << だけでなく、pushメソッドを使っても要素を追加できる
# pushメソッドの場合は複数の値を追加できる
a = []
p a.push(1) #=>[1]
p a.push(2, 3) #=>[1,2,3]

# 指定した値に一致する要素を削除したい場合はdeleteメソッドを使います
a = [1, 2, 3, 1, 2, 3]
# 値が2である要素を削除する（削除した値が戻り値になる）
p a.delete(2) #=>2
p a #=>[1,3,1,3]
# 存在しない値を指定するとnilが返る
p a.delete(5) #=>nil
p a #=>[1,3,1,3]

# 4.7.3 配列の連結
# 2つの配列を連結したい場合は concat メソッドか、+ 演算子を使う
# 違いは元の配列を変更するかどうか（破壊的かどうか）
# concat メソッドを使って配列を連結すると、元の配列（メソッドを呼び出した側の配列）が変更される

a = [1]
b = [2, 3]
a.concat(b) #=>[1,2,3]
# aは変更される（破壊的）
p a #=>[1,2,3]
# bは変更されない
p b #=>[2,3]

# 一方、+を使うと元の配列を変更せず、新しい配列を作成します。
a = [1]
b = [2, 3]
p a + b #=>[1,2,3]
# aもbも変更されない（非破壊的）
p a #=>[1]
p b #=>[2,3]

# どちらも「配列を連結する」という用途は同じだが、破壊的な変更は大きなプログラムやフレームワークの中では思いがけないところに悪影響を与えてしまう場合がある
# なので、「どうしても」という場合以外は + 演算子を使う

# 4.7.4 配列の和集合、差集合、積集合
# Rubyの配列は|、-、&を使って、和集合、差集合、積集合を求めることが可能

# | は和集合を求める演算子 -> 2つの配列の要素をすべて集め、重複しないようにして返す
a = [1, 2, 3]
b = [3, 4, 5]
p a | b #=>[1,2,3,4,5]

# - は差集合を求める演算子 -> 左の配列から右の配列に含まれる要素を取り除く
a = [1, 2, 3]
b = [3, 4, 5]
p a - b #=>[1,2]

# & は積集合を求める演算子 -> 2つの配列に共通する要素を返す
a = [1, 2, 3]
b = [3, 4, 5]
p a & b #=>[3]

# |、-、&のいずれも、元の配列は変更しない（非破壊的）
# なお、Rubyには配列よりも効率的に集合を扱えるSetクラスもある
# 本格的な集合演算をする場合は、配列よりもSetクラスを使うほうが良い

require 'set'
a = Set.new([1, 2, 3])
b = Set.new([3, 4, 5])
p a | b #=>#<Set:{1,2,3,4,5}>
p a - b #=>#<Set:{1,2}>
p a & b #=>#<Set:{3}>

# 4.7.5 多重代入で残りの全要素を配列として受け取る
# 多重代入では左辺の変数よりも右辺の個数が多い場合は、はみ出した値が切り捨てられる
e, f = 100, 200, 300
p e #=>100
p f #=>200
# しかし、左辺の変数に*を付けると、残りの全要素を配列として受け取ることが可能
e, *f = 100, 200, 300
p e #=>100
p f #=>[200,300]

# 4.7.6 1つの配列を複数の引数として展開する
# pushメソッド: a.push(2,3) のようにして、複数の要素を一度に追加できる
a = []
p a.push(1) #=>[1]
# 2と3を一度に追加する
p a.push(2, 3) #=>[1,2,3]

# この2,3が配列になっていた場合
a = []
b = [2, 3]
p a.push(1) #=>[1]
# 配列をそのまま追加（a.push([2,3])と同じ）
p a.push(b) #=>[1,[2,3]]

# メソッドの引数に配列を渡すとき「1つの配列」ではなく、配列を展開して「複数の引数」として渡したい場合は、配列の前に*を置く（splat展開）
a = []
b = [2, 3]
p a.push(1) #=>[1]
# 配列を*付きで追加（a.push(2,3)と同じ)
p a.push(*b) #=>[1,2,3]

# 4.7.7 メソッドの可変長引数
# 可変長引数: pushメソッドのように、個数に制限のない引数のこと
# 自分で定義するメソッドで可変長引数を使いたい場合は、引数名の手前に*を付ける

# def メソッド名(引数1, 引数2, *可変長引数)
#   メソッドの処理
# end

# 可変長引数は配列として受け取ることができる
# 例) 引数として渡された人名の全員にあいさつをするメソッド (joinメソッド: 引数の区切り文字を使って配列を1つの文字列にする)
def greeting(*names)
  "#{names.join('と')}、こんにちは！"
end
p greeting('田中さん') #=>"田中さん、こんにちは！"
p greeting('田中さん', '鈴木さん') #=>"田中さんと鈴木さん、こんにちは！"
p greeting('田中さん', '鈴木さん', '佐藤さん') #=>"田中さんと鈴木さんと佐藤さん、こんにちは！"

# 4.7.8 *で配列同士を非破壊的に連結する
# []の中に*付きで別の配列を置くと、その配列が展開されて別々の要素になる(splat展開の一種)
a = [1, 2, 3]
# []の中にそのまま配列を置くと、配列の配列になる
p [a] #=>[[1,2,3]]
# *付きで配列を置くと、展開されて別々の要素になる
p [*a] #=>[1,2,3]
# これを利用すると、別の配列を要素の一部とする新しい配列を作ることができる
a = [1, 2, 3]
p [1, 0, *a, 4, 5] #=>[1,0,1,2,3,4,5]
# *ではなく、以下のように+を使うこともできるが、*を使ったほうが簡潔なコードになる
a = [1, 2, 3]
p [1, 0] + a + [4, 5] #=>[1,0,1,2,3,4,5]

# 4.7.9 ==で等しい配列かどうか判断する
# ==を使うと、左辺と右辺の配列が等しいかどうかをチェックできる
# この場合、配列の全要素を==で比較し、すべて等しい場合に「2つの配列は等しい」と判断される

# 配列が等しい場合
p [1, 2, 3] == [1, 2, 3] #=>true
# 配列が等しくない場合
p [1, 2, 3] == [1, 2, 4] #=>false
p [1, 2, 3] == [1, 2] #=>false
p [1, 2, 3] == [1, 2, 3, 4] #=>false

# 4.7.10 %記法で文字列の配列を簡潔に作る
# 配列は[]を使って作成することが多いが、文字列については%記法の%wまたは%Wを使って作成する方法がある
# %記法を使うと、カンマではなく空白文字（スペースや改行）が要素の区切り文字となる
# また、文字列をシングルクオートやダブルクオートで囲む必要もないため、結果として[]を使う場合よりもコードが短くなる

# []で文字列の配列を作成する
p ['apple', 'melon', 'orange'] #=>["apple","melon","orange"]
# %wで文字列の配列を作成する（!で囲む場合）
p %w!apple melon orange! #=>["apple","melon","orange"]
# %wで文字列の配列を作成する（丸カッコで囲む場合）
p %w[apple melon orange] #=>["apple","melon","orange"]
# 空白文字（スペースや改行）が連続した場合も1つの区切り文字と見なされる
p %w[
  apple
  melon
  orange
] #=>["apple","melon","orange"]

# 値にスペースを含めたい場合はバックスラッシュでエスケープする
p %w[big\ apple small\ melon orange] #=>["bigapple","smallmelon","orange"]

# 式展開や改行文字（\n）、タブ文字（\t）などを含めたい場合は、%W（大文字のW）を使う
prefix = 'This is'
p %W[#{prefix}\ an\ apple small\nmelon orange]
#=> ["This is an apple", "small\nmelon", "orange"]

# 4.7.11 文字列を配列に変換する
# charsメソッド: 文字列中の1文字1文字を配列の要素に分解する
'Ruby'.chars #=>["R","u","b","y"]
# splitメソッド: 引数で渡した区切り文字で文字列を配列に分割する
'Ruby,Java,Perl,PHP'.split(',') #=>["Ruby","Java","Perl","PHP"]

# 4.7.12 配列に初期値を設定する
# ここまで配列の作成は[]を使ってきたが、このほかにもArray.newを使って作成する方法がある
# 以下のコードは a=[]と同じ
a = Array.new
# Array.newに引数を渡すと、その個数分の要素が追加される(このときの初期値はnil)
# 要素が5つの配列を作成する
a = Array.new(5)
p a #=>[nil,nil,nil,nil,nil]
# さらに第2引数を指定すると、nil以外の初期値を設定できる
# 要素が5つで0を初期値とする配列を作成する
a = Array.new(5, 0)
p a #=>[0,0,0,0,0]
# Array.newではブロックを使って初期値を設定することもできる
# ブロックは作成する要素の数だけ呼ばれ、ブロック引数には要素の添え字が渡される
# 配列にはブロックの戻り値がそれぞれ初期値として設定される
# 要素数が10で、1,2,3,1,2,3...と繰り返す配列を作る
a = Array.new(10) { |n| n % 3 + 1 }
p a #=>[1,2,3,1,2,3,1,2,3,1]

# 4.7.13 配列に初期値を設定する場合の注意点
# 要素が5つで'default'を初期値とする配列を作成する
a = Array.new(5, 'default')
p a #=>["default","default","default","default","default"]
# 1番目の要素を取得する
str = a[0]
p str #=>"default"
# 1番目の要素を大文字に変換する（破壊的変更）
str.upcase!
p str #=>"DEFAULT"
# 配列の要素すべてが大文字に変わってしまった！
p a #=>["DEFAULT","DEFAULT","DEFAULT","DEFAULT","DEFAULT"]
# これは配列の全要素が同じ文字列オブジェクトを参照しているために発生する問題
# 一見、配列の各要素は別々のように見えても、実際は1つのオブジェクトに紐付いてしまっているため、
# そのオブジェクトが変更されると無関係に見えるほかの要素も一緒に変更されてしまう

# この問題を避けるためには引数ではなく、ブロックで初期値を渡す
# ブロックを使って、ブロックの戻り値を初期値とする
# ブロック引数には添え字が渡されるが、ここでは使わないのでブロック引数を省略
a = Array.new(5) { 'default' }
p a #=>["default","default","default","default","default"]
# 1番目の要素を取得する
str = a[0]
p str #=>"default"
# 1番目の要素を大文字に変換する（破壊的変更）
str.upcase!
p str #=>"DEFAULT"
# 1番目の要素だけが大文字になり、ほかは変わらない
p a #=>["DEFAULT","default","default","default","default"]
# ブロックを使うと、ブロックが呼ばれるたびに文字列の"default"が新しく作成される為、結果として配列の各要素は別々の文字列を参照することになる
# 「同じ値で同一のオブジェクト」なのか、「同じ値で異なるオブジェクト」なのか、意識してコードを書かないと思わぬ不具合を作ってしまう
# mutable(変更可能): String クラス
# immutable(不変): 数値（IntegerクラスやFloatクラス), シンボル（Symbolクラス）, true/false（TrueClassクラスとFalseClassクラス）, nil（NilClassクラス）
# 文字列のようなミュータブルなオブジェクトはfreezeメソッドを使って、変更不可にすることもできる

# 4.8 ブロックについてもっと詳しく
# 4.8.1 添字付きの繰り返し処理
# eachメソッドでは何番目の要素を処理しているのか、ブロック内で判別できない
# 繰り返し処理をしつつ、処理している要素の添え字も取得するには each_with_index メソッドを使う: ブロック引数の第2引数に添え字を渡してくれる
fruits = %w[apple orange melon]
# ブロック引数のiには0,1,2...と要素の添え字が入る
fruits.each_with_index { |fruit, i| puts "#{i}:#{fruit}" }
#=> 0:apple
# 1: orange
# 2: melon

# 4.8.2 with_indexメソッドを使った添え字付きの繰り返し処理
fruits = %w[apple orange melon]
# mapとして処理しつつ、添え字も受け取る
p fruits.map.with_index { |fruit,i| "#{i}:#{fruit}" } #=>["0:apple","1:orange","2:melon"]
# with_indexメソッドはmap以外のメソッドとも組み合わせることが可能
fruits = %w[apple orange melon]
# 名前に"a"を含み、なおかつ添え字が奇数である要素を削除する
p fruits.delete_if.with_index { |fruit, i| fruit.include?('a') && i.odd? } #=>["apple","melon"]

# with_indexメソッド: Enumeratorクラスのインスタンスメソッド
# eachメソッドやmapメソッド、delete_ifメソッドなど繰り返し処理を行うメソッドの大半はブロックを省略して呼び出すと、Enumeratorオブジェクトを返す
fruits = %w[apple orange melon]
# ブロックなしでメソッドを呼ぶとEnumeratorオブジェクトが返る
# よってwith_indexメソッドが呼び出せる
p fruits.each #=>#<Enumerator:["apple","orange","melon"]:each>
p fruits.map #=>#<Enumerator:["apple","orange","melon"]:map>
p fruits.delete_if #=>#<Enumerator:["apple","orange","melon"]:delete_if>
# このようになっているため、with_indexメソッドはあたかもさまざまな繰り返し処理用のメソッドと組み合わせて実行できるように見える

# 4.8.3 添え字を0以外の数値から開始させる
# each_with_indexメソッドやwith_indexメソッドを使うと添え字はいつも0から始まる
# これを0以外の数値から始めたい場合: with_indexメソッドに引数を渡す
fruits = %w[apple orange melon]
# eachで繰り返しつつ、1から始まる添え字を取得する
fruits.each.with_index(1) { |fruit, i| puts "#{i}:#{fruit}" } #=>1:apple #2:orange #3:melon
# mapで処理しつつ、10から始まる添え字を取得する
p fruits.map.with_index(10) { |fruit, i| "#{i}:#{fruit}" } #=>["10:apple","11:orange","12:melon"]
# ちなみに、each_with_indexメソッドには引数を渡せないため、上のコードのようにeach.with_index(1)の形で呼び出す必要がある

# 4.8.4 配列がブロック引数に渡される場合
# たとえば、縦の長さと横の長さを配列に格納し、それを複数用意した配列があったとする
# これをeachメソッドなどで繰り返し処理すると、配列がブロック引数に渡ってくる
dimensions = [[10, 20], [30, 40], [50, 60]]
# 面積の計算結果を格納する配列
areas = []
# ブロック引数が1個であれば、ブロック引数の値が配列になる
dimensions.each do |dimension|
  length = dimension[0]
  width = dimension[1]
  areas << length * width
end
p areas #=>[200,1200,3000]

# ブロック引数の数を2個にすると、縦と横の値を別々に受け取ることができ、上のコードよりもシンプルに書ける
dimensions = [[10, 20], [30, 40], [50, 60]]
# 面積の計算結果を格納する配列
areas = []
# 配列の要素分だけブロック引数を用意すると、各要素の値が別々の変数に格納される
dimensions.each do |length,width|
  areas << length * width
end
p areas #=>[200,1200,3000]

# 4.8.5 ブロックローカル変数
